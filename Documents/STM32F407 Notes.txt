**********************************************************STM32F407 DISCOVERY BOARD NOTES******************************************************************

1)Base Address of Flash Memory -> 0x0800 0000

2)Base Address of RAM Memory -> 0x2000 0000

3)Base Address of AHB1 bus peripheral register 
  AHB1_PERI_START_ADDRESS  : 0x4002 0000
  AHB1_PERI_END_ADRESSS    : 0x4007 FFFF 

4)Base Address of GPIOA Register -> 0x4002 0000 to 0x4002 03FF

5)Base Address of RCC engine register -> 0x4002 3800 - 0x4002 3BFF

6)Base Address of APB1 peripheral register ->0x4000 0000

7)Base Address of SRAM2.
  There are two SRAM
  SRAM1 starts from-> 0x2000 0000
  SIZE of SRAM1 =X
  BASE_ADDRESS_OF_SRAM2 = BASE_ADDRESS_OF_SRAM1 + X

8)Base address of ADC1 Register -> 0x4001 2000

_________________________________________________________________________________________________________________________
BUS INTERFACE NOTES 

*If Instructions are present between address 0x00000000 to 0x1FFFFFFC, then cortex processor will fetch instructions
 using the I-CODE BUS INTERFACE 
*If the instructions are present outside the range 0x00000000 to 0x1FFFFFFC,then cortex processor will fetch instructions
 using System Bus
 
*If data is present between address 0x00000000 to 0x1FFFFFFF, then cortex processor will fetch data using the D-CODE BUS
INTERFACE 
*If the data is present outside the range 0x00000000 to 0x1FFFFFFF,then cortex processor will fetch data using System Bus
_________________________________________________________________________________________________________________________

QA on Bus interface.

Ref: STM32F407VGT6 Micro-controller.

1) Is it true?, System Bus is not connected to FLASH memory ? ---> YES True( Page 73 in data sheet)
2) System bus can operate at 168Mhz? --->True
3)SRAMs are connected to system bus ? ---->True
4)APB1 can operate up to 168Mhz ?---> False
5)Let's say i have peripheral data sheet , which says its operating frequency must be above 95Mhz. Can we connect this peripheral
 to APB2 ? --->No(APB2 max = 84Mhz) 
6)Processor can simultaneously fetch instructions and data from SRAM ? ---> No as there is Only one Bus.
7)Processor can simultaneously fetch instructions and data from FLASH? ---->YES, separate bus Icode and Dcode
8)What is the Max HCLK value of MUC? --> 168Mhz (Current operating frequency of AHB bus is called HCLK).
9)What is the Max PCLK1 value of MCU? -->42Mhz (Operating frequency of APB1)
10)What is the Max PCLK2 value of MCU?--->84Mhz (Operating frequency of APB2)
11)GPIO and Processor communicate via AHB1 Bus ? --->True.
12)USB OTG and processor communicate via ABH2 Bus ? ---> True
13)US OTG and GPIOs can communicate with processor concurrently/simultaneously ? --> False. 
14)Processor can talk to FLASH and SRAM simultaneously ? -->True.
_______________________________________________________________________________________________________________________________

BUS MATRIX

*Bus matrix beautiful diagram @ page 18 of AN4031.
________________________________________________________________________________________________________________________________

********************* MUC CLOCK **********************************
MCU has 3 main clock sources:

1) Crystal Oscillator(HSE) - This is external clock source, can be connected to MCU.
                             HSE - High speed External 
2) RC Oscillator (HSI) -All modern MCU comes with internal RC Oscillator, which can be just activated to use.
                          HSI - High Speed Internal.
3) PLL(Phase locked loop - It is also Implemented internally in MCU, It uses low frequency sources to generate high frequency
   clock. (PLLCLK).
   
 In Case of STM32F407VGT6,( Data sheet page 216,  Figure 21. Clock tree)
 (**USE STM32 CUBE MX and select STM32F407 board, and goto Clock Configuration for Better Clock Tree**)
 
  *HSI RC -> 16Mhz. 
  *HSE -> Ref to Clock Tree, an external crystal has to be connected to HSE input and crystal has to be (4Mhz to 26Mhz).
  *PLL -> It takes HSI /HSE as input.
  
 #RC Oscillator vs Crystal - Crystal is more Stable and accurate than internal RC.
 
 ->All Three of these clock sources are given to SYSTEM CLOCK MULTIPLEXER, where we can select clock source.
 ->Output of this MUX is SYSCLK(i.e, System Clock).
 
 ->SYSCLK : Main clock of MUC, using this other clocks are derived(Ex: Peripheral, Bus clocks ect).
 ->SYSCLK is given directly to Ethernet PTP Clock.
 
 ->HCLK is derived from SYSCLK with a Prescaler in between , which brings down the clock frequency.
 ->HCLK goes directly to AHB bus,core, memory and DMA.
 ->HCLK goes to Cortex System Timer.
 ->HCLK goes directly to Cortex Processor (FCLK Cortex Clock).
 
 ->PCLK1 and PCLK2 are derived from HCLK.
 ->PCLK1 goes to APB1 peripheral clock and APB1 Timer Clock
 ->PCLK2 goes to APB2 peripheral clock and APB2 Timer Clock
 
*By default MCU uses HSI (i.e internal RC Oscillator) as SYSCLK. Which means after reset HSI is used as SYSCLK Source.



----------------------------------------------------------------------------------------------------------------------------------------------
****************************************************MCU CLOCK last**********************************************************************

Clock Source in MCU

1)High Speed Internal(HSI) Oscillator
2)High Speed External(HSE) Oscillator
3)Phase Locked Loop
4)Low speed internal(LSI)clock
5)Low speed External(LSE)clock

->Each clock can be turned on/off as required. Turning off the unused clock will reduce the power consumption of MCU.
-> Out of 5, 1,2 and 3 are high speed clocks, 4 and 5 are low speed clocks.


1)High Speed Internal(HSI) Oscillator
->After Reset , by default HSI is used to provide clock to MCU, which means by default MCU select HSI as clock. This clock is internal to MCU
and its value is 16Mhz in STM32F407 MCU. 
->The HSI internal oscillator has advantage of providing clock at low cost as no external component is required to use this clock. 
it also has faster start up time than the external crystal oscillator however, frequency is less accurate than the external crystal oscillator.

System CLock: - Selection of system clock is important as all other clocks are derived using system clock.
Some peripheral such as OTG,USB, Random number generator , SDIO(secure digital Io) - not clocked by sys clock instead they get clock directly 
from PLL when PLL circuitry is enabled.


2)High Speed External(HSE) Oscillator
->if you want to use HSE as system clock an external crystal oscillator whose frequency must be in range (4 to 6Mhz) has to b connected. In our board
manufacture has connected 8mhz crystal.

3)Phase Locked Loop
->The power of PLL lies in producing high frequency clocks of various programmable range. By using PLL you can boost the HCLK(AHB) upto 168Mhz in STM32F4xx MCU.
  All the modern MCU has PLL. If you want to use MCU-buses at their max frequencies then we have to PLL only.  
-> You have to feed either HSI or HSE to the PLL as input frequency. Then by using all PLL circuitry setting it produces PLL output clock in couple of 100s of MHZ.
So to RUN STM32F407 at its maximum frequency(168Hhz) you have to use PLL. 



Clocking MCU using external Crystal Oscillator
->As explained before, you can connect (4 to 26Mhz) crystal oscillator to MCU. In STM32 board manufacturer has connected 8Mhz Crystal. 
->Even though it is connected its useless as its disabled. 
->Before using external oscillator , we need enable it by using External RC oscillator.
->Register used is RCC_CR
->u can see bit 17 and 16 (HSE On and HSE RDY)
  *Inorder to enable HSE ( HSEON bit is made 1), then u have to wait untill HSERDY flag become 1- which indicates the HSE oscillator is read to use.
  *It important to wait untill HSERDY flag is set. Now HSE is ready but it is not yet set as SYSCLK.
 -> So to set HSE as System clock RCC_CFGR is used. 
    *Here bit 0 and 1 are used to switch system clock. - (01: HSE oscillator selected as system clock )
	*Once we do this HSE will be used as system clock.
	
Testing Clock Frequency
  ->In clock tree diagram , MC02 and MC01 (thses are MCU clock ouput) , all the different sources can be brought out from this pins. 
  -> MCO1 = PA8,  (HSI, LSE, HSE and PLL can be brought out on this pin )
  -> MC02 = PC9,  (HSE,PLL,SYSCLK, PLLI2S can be brought out on this pin)
  -> In  
  
  
Clocking MCU by using PLL 
 -> In PLL the VCO(voltage controlled oscillator) is the one which boost the frequency given to its input , as per ref manual, input to VCO must be between
 1 to 2MHZ. 
 ->So we use Prescaler value PLLM to limit input to VCO. Divide the HSE by 8 so that input to VCO becomes 1Mhz. 
 ->after the use PLLN prescalar to produce VCO output frequency.
 -> as per formula given PLLN can take value between 192 to 432. VCO output frequency = VCO input frequency × PLLN 
 so suitable PLLN value is used to get 168Mhz. 
 ->Then use PLLP to provide main sys clock.
 ->PLLP =2, so VCO out = 336. 
 -> So now PLLN = 336. 

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
_________________________________________________________________________________________________________________________ 
 
RCC(Reset Clock Control)

->Before using any peripheral its clock should be enabled.
->Referring MUC Block Diagram, all different peripheral drives the clock from bus which it is connected.
->By default almost all the peripheral are deactive, which means there clocks are not enabled.
->RCC engine of MCU gives various registers to enable and disable various peripheral clocks.

#To Understand enabling clock before using peripheral refer Kiel project "peripheral_clock"

*Troubleshoot Tip 1 : Check whether the clock required is enabled or not.
_________________________________________________________________________________________________________________________

VECTOR TABLE OF MCU.

* What is Vector Table?
-> It is a table of vectors. Generally vectors are related to directions , as we know VECTORS in physics has both magnitude
   and direction. In MCU we can compare pointers are like direction, as it points to certain addresses. So we can say vector
   table is table holding specific address.
   Next question is obviously address of what?. It actually contains the addresses of exceptions handlers.
   
-> Exception handler --> System Exceptions(MUC internally generates) + Interrupts(External)
   15 System Exceptions + 240 External Interrupts.
   

Referring : Table 61. Vector table for STM32F405xx/07xx and STM32F415xx/17xx (Page 372 of RM0090).

1) There are 6 columns in Vector Table -> Position,Priority, Type of priority, Acronym, Description and Address.
2) We can see that position is kept empty for all the system exceptions, system exceptions comes from processor(ARM)end.
   So vendor ST does not have control  over these. These positions are with respect to NVIC.
   Ex : Watch dog exceptions is Position 0 w.r.t to NVIC.
   Another name for position is IRQ Number.
3) Priority column gives the priority of exceptions and interrupts reset has highest priority of -3.   
4) Type of Priority : Reset, NMI and HardFault have fixed priority, which means no one can change it. Apart from these 3 the
   remaining has settable priority.
   
5) Address column tells that where exactly in the processor memory map you have to keep the corresponding exception handler.
   Handler is just a C function which takes care of that exception.
   Example : if we have implemented a function to handle NMI exception in your program then address of that handler must be kept
   at 0x0000 0008. That is function pointer should be kept in this addresses.
6) The very first address that is "0x00000000" is reserved and it has special data -> STACK Pointer value in Cortex Processor.
   Before coming to reset handler, processor loads the value stored in 0x00000000 location into stack pointer, because always stack
   pointer must be initialized before entering into any handler. So its necessary for us to keep a valid value at this address. 
   All this things are handled in startup code.   
_______________________________________________________________________________________________________________________________________

MCU INTERRUPT DESIGN


 ->We can observer here that not all interrupts goes directly to NVIC. Some peripheral deliver their interrupt to NVIC over the EXTI Lines.
 Some peripheral deliver their interrupt directly to NVIC. This is the design of ST.
 
 ->Some quick understanding before we proceed to design are as fallows :
    1) How does GPIO pin interrupts the processor?
    2) what is the design?
    3) How vendor actually delivers the GPIO interrupt to processor.
	
	
Ref: Figure 41. External interrupt/event controller block diagram (Page 380 of RM0090)
  1) ST MCU has a Engine Called EXTI (External Interrupt Controller).
  2) This engine is actually hanging on APB Bus(APB2), so it drives the clock from PCLK2 .
  3) This engine is finally connected to NVIC Interrupt Controller. This engine gives 23 lines to NVIC.
  4) In vector table we can see 23 entries related to EXTI.


Ref: Figure 42. External interrupt/event GPIO mapping (STM32F405xx/07xx and STM32F415xx/17xx) (Page 382 of RM0090)
    1) Figure 42 shows how exactly the GPIOs are delivering their interrupts to NVIC.
	2)All the 0th Pins (PA0,PB0,PC0,PD0,PE0,PF0,PG0,PH0 and PI0) of GPIO ports are connected to EXTI0 line through MUX.
	  EXTI0[3:0] bits in the SYSCFG_EXTICR1 register is used for this purpose.
	3)In the similar way from figure 42 we can see remaining pins how they deliver their interrupts.
	
-> Ref : Figure 41, We need to Know about Pending Request Register.
   Pending Request register: This Register tells us interrupt on which which EXTI line is pending.
                             When interrupt occurs corresponding bit in This register goes high.
							 Once interrupt event is finished, its programmer responsibility to clear this bit.
							 If the bit is not cleared, it leads to bug ->Refer written notes.
							 
________________________________________________________________________________________________________________________________________________

GPIO Register


* GPIO port mode register (GPIOx_MODER) (x = A..I/J/K)

  -> Before using any GPIO port, we should decide its mode, whether you want to use it as input, output, alternate functionality or analog mode.
     MODERy[1:0]: Port x configuration bits (y = 0..15)
           These bits are written by software to configure the I/O direction mode.
            00: Input (reset state) -> By default.
            01: General purpose output mode
            10: Alternate function mode -> Such as UART, SPI, I2C ect.
            11: Analog mode
  ->Before Using any GPIO for any purpose, configuring this register is must.
  
* GPIO port output type register (GPIOx_OTYPER) (x = A..I/J/K)
   -> When GPIO pin is in output mode, this register is used to choose output type.
          Bits 15:0 OTy: Port x configuration bits (y = 0..15)
          These bits are written by software to configure the output type of the I/O port.
          0: Output push-pull (reset state)
          1: Output open-drain
	 
* GPIO port output speed register (GPIOx_OSPEEDR) (x = A..I/J/K)
  QA : Why do we have speed setting for I/O pin?
       Ans-> To save power.
	   
	   OSPEEDRy[1:0]: Port x configuration bits (y = 0..15)
       These bits are written by software to configure the I/O output speed.
       00: Low speed
       01: Medium speed
       10: High speed
       11: Very high speed
	   
	   ->LOW speed GPIO consumes less power as compared to HIGH Speed GPIO.
	   ->But low speed GPIO have larger (Trise ->rising edge) and (Tfall->falling edge)(SLEW RATE). Which may not be suitable for some application.
	   ->GPIO Fast toggle capable of every two clock cycle -> which means if GPIO is high and it needs to go low it needs minimum two processor clock cycle.
	     Assuming MCU is running at 48Mhz, then fastest toggle speed of GPIO is 24Mhz.
		 
* GPIO port pull-up/pull-down register (GPIOx_PUPDR)(x = A..I/J/K)
       -> Internal pull-up/pull-down registers can be configured on the GPIO pin which are in input/output mode.
	   
* GPIO port input data register (GPIOx_IDR) (x = A..I/J/K)
        ->It is 32 bit read-only register, where upper 16bits are not used.
		-> Value of this register bit gives corresponding GPIO pin voltage status(HIGH/LOW).
		->Reading this register gives voltage on each pins of GPIO Port.
		
* GPIO port output data register (GPIOx_ODR) (x = A..I/J/K)
        ->It is 32 bit write-only register, where upper 16bits are not used.
		-> In this register each bit is used to write a ouput value to corresponding pin of port.

* Very Important GPIO Configuration Register -> GPIO Alternate Function Register -> There are Two registers.
      1)GPIO alternate function low register (GPIOx_AFRL) (x = A..I/J/K) -> Used for Pin 0 to 7.
	  2)GPIO alternate function high register (GPIOx_AFRH) (x = A..I/J)  -> Used for Pin 8 to 15.
	  ->Each GPIO Pin can have 16 Different alternate functions (4 bits are used for selection).
	  Ref : Figure 26. Selecting an alternate function on STM32F405xx/07xx and STM32F415xx/17xx ->Gives alternate Function.
  
  		

ENABLING/DISABLING OF GPIO PERIPHERAL CLOCK

    ->In STM32F4xx MCU, all peripheral clocks are managed by RCC Block.
		->By default all peripheral clock are disabled for saving power.
		->So before using any GPIO, its clock should be enabled.
		->All GPIO Ports are connected to AHB1 BUS.
		-> RCC AHB1 peripheral clock enable register (RCC_AHB1ENR) is used.
		
_______________________________________________________________________________________________________________________________________

GPIO Driver Development

-> For driver development no any STM provided drivers are used.
-> We will use CMSIS Core API header given BY ARM.
-> It is always better to write HEADEDR file first before writing source / .c files.
-> Header file has 3 Main section------> 1)GPIO Register bit definition macros.
                                         2)Data structure for GPIO Pin Initialization.
                                         3)Driver Exposed API.
										 

 ****External Interrupt Register***	 (Page 384 of RM0090)

->Interrupt mask register (EXTI_IMR) - Used to mask/un-mask of interrupts over 23 lines which are handled by external interrupt controller
                                     - Bit 0 to 15 are used to mask/un-mask interrupts on 16EXTI lines(EXTI0 to EXTI15)
                                     - 1 = Mask, 0 = unmask.

->Rising trigger selection register (EXTI_RTSR)	 								 
									 -By using this register we can configure the interrupt as rising edge triggered.
									 -Bits 22:0 TRx: Rising trigger event configuration bit of line x
                                                  0: Rising trigger disabled (for Event and Interrupt) for input line
                                                  1: Rising trigger enabled (for Event and Interrupt) for input line
->Falling trigger selection register (EXTI_FTSR)
									 - By using this register we can configure the interrupt as falling edge triggered.	

->Pending register (EXTI_PR)        -Whenever the interrupt occurs on any of 23 External interrupt lines, corresponding bit will be set 
                                     by hardware in pending register.
                                    -This is to indicate that interrupt has occured on that line.
                                    -It is programmer responsibility to clear this bit.( This bit is cleared by programming it to ‘1’.)									
___________________________________________________________________________________________________________________________________________________________

**************************SPI (Serial peripheral interface )**************************************************************


Ref  : The block diagram of the SPI is shown in Figure 246. (Page 876 0f RM0090)

 -> From block diagram we can see that 4 pins are coming out - MOSI, MISO, SCLK and NSS(Slave select).
 -> the heart of the block diagram is the shift register with two buffer one is the TX buffer another is the RX Buffer.
 -> TX and RX buffer are accessible over APB1/APB2 Bus.
 -> To transmit  the data , the data has to be written to the TX buffer, whose content then get loaded to shift register then transmitted.
 -> When the shift register receives the complete byte it transfer it to RX buffer where we can read it.
 -> The we have couple of control register SPI_CR1, SPI_CR2 which are used to control SPI operations.
 -> One status register SPI_SR. It holds the status of various SPI events such TX event, RX event and error event etc.
 -> Clock is produced by baud rate generator block which is controlled by BR0,BR1,BR2 bits in control register.
 
 
 SPI Peripheral Clock & Serial Clock
      
     -> There are 3 SPI peripherals. Out of which SPI1 is connected to APB2 bus and SPI2,SPI3 are connected to APB1 bus.
     -> SPI clock speeds are dependent on APB1/APB2. We already know APB1 bus has max 42MHz and APB2 has max 84Mhz. These are represented by peripheral
        f(pclk).
     -> So for SPI2/SPI3 the max clock speed is 42Mhz as it is hanging on APB1 bus.
     -> f(pclk) is given to SP2/SPI3. 
     -> after this there is prescalar whose min value is 2 which results in SCLK.
     -> So if we take HSI(16Mhz) as clock source, APB1/APB2 will have 16Mhz speed and f(pclk) = 16Mhz and SCLK = 8Mhz.(Ref diagram in notes).
     -> similar way for SP1 max clock speed is 84Mhz as it is hanging on APB2.
	 
 SPI Registers
 
     - SPI Control Registers
	   ->There are two control registers, SPI_CR1 and SPI_CR2.
	   
	   SPI_CR1 Register.
	      ->SPE bit is used to enable the SPI peripheral.(Until this bit is 1 SPI peripheral will never work).
		  ->SSM ,SSI bit are used to select slave using software.
		  
	   SPI_CR2 Register.
	       ->TXEIE pin manages TXE event(Transmit buffer empty event) that is whenever the TX buffer is emty the TXE flag is set in the status register.
		     then firmware will get interrupt when TXEIE pin is set.
		   ->RXNEIE pin enables interrupt for RX buffer not empty event. Whenever RX buffer is not empty that is when it has some data RXNE bit is set in status
             register. So if we enable this pin firmware will get interrupt when RXNE pin is set.
			 
	   SPI Data Register(SPI_DR)
	       ->SPI data register is 16-bit wide. IF we transfer 1byte upper bits (8 to 15) are unused.
		   ->SPI allows you to transfer 16bit at a time thats the reason data register is 16bit wide. But by default its 1byte.
		   ->The data register is split into 2 buffers - one for writing (Transmit Buffer) and another one for reading (Receive buffer). A write to the data 
		      register will write into the Tx buffer and a read from the data register will return the value held in the Rx buffer.(ref diagram in notes)
		
		SPI Status Register(SPI_SR)
		   ->First two bits holds TXE and RXNE events. When TX buffer is empty TXE bit is set to 1. When RX buffer is not emty RXNE bit is set.
		   ->TXE and RXNE bits are very usefull during data transfer, firmware should either poll these bits or get interrupt upon setting these bits during data transmission.
		   ->FRE,OVR, MODF, CRC ERR, UDR are used to indicate error events. These flags are set when corresponding error occurs.
		   ->BSY (busy flag), is set whenever SPI is doing TX/RX.
		   

***********************************************************SPI Driver Development ********************************************************************************

     Header file has 3 main section - 1) SPI bit definition
	                              2) Data structure used by SPI Driver.
                                      3) Driver exposed API.

 
    Configuring NSS
            ->NSS is slave select pin which is typically on slave side. Master drive NSS pin to low whenever it wants to communiate with perticular slave.
            ->In this microcontroller the NSS pin can be handled in 2 ways
                    1)Software slave managment
                    2)Hardware slave managemet

              1)Software Slave management
                     ->When software slave management is enabled using SSM bit in SPI_CR1 register(when SSM bit is 1), NSS pin cannot be driven high or low by
                       external IO lines such as master. Instaed this NSS pin is handled by software by using SSI bit in SPI_CR1 register. The value of SSI bit
                       is forced onto NSS pin and IO value of NSS is ignored.
                       if software makes SSI=1 , then NSS = HIGH
                                         SSI=0 , then NSS = LOW
                     -> So when software slave management is used , SSI bit acts as "handle" to drive NSS pin. So no extra pin is needed to be connnected from master
                        to slave.

              What is the advantage of this mode?
                      ->When there is only one master and one slave, if we use SSM then there is no need to connect one pin from master to slave , which saves one Pin.


              2)Hardware Slave management
                      ->When there are multiple slaves the SSM cannot be used.
                      -> So when SSM bit is 0 - Hardware slave management is used.
                      -> So NSS pin can be driver from external IO line, such as Gpio of master.
                      ->When device is in master mode (page  877 of RM0090) , NSS pin is not used and must be kept high.way to do so is simply select SSM=1.
                      

    -> it is recommended to enable spi (that is -> hal_spi_enable()) after all the necessary settings are configured.


   How SPI peripherals will interrupt the processor and how interrupt is enabled?
            -> Table 126. SPI interrupt requests ( data sheet page 898)
            -> This table shows on what cases the SPI peripherla can interrupt the Processor.
            -> (Refer Notes : SPI interrrupts)
            ->Unless we enable the TXEIE and RXNEIE interrupt in control register firmware will not get any interrupt when TXE and RXNE flags are set in status regsiter. 
            ->"void hal_i2c_spi_irq_handler(spi_handle_t *hspi)"---> this function is called by application whenever it gets spi interrupt.
            -> Handling SPI interruptin code (refer notes).

			
***********************************************************************************************************************************************************************************************
                                                ***********Inter-Integrated Circuit ( I2C protocol)****


    Ref : Figure 239. I2C block diagram for STM32F40x/41x(Page 842 of RM0090)
	
	-> 3 pins are coming out--- SDA,SCL and SMBA. SMBA is used in SMB(System management bus) Protocol, which is almost identical to i2c bus. Initially Philips developed I2C, years later Intel
	   came up with SMB which is an extension of I2C.
	-> From the functional block we can see there is one shift register and one associated data register(In case of SPI there were two buffer TX and Rx since SPI was full duplex). Since I2C 
	   is half duplex one data register is sufficient.
	-> Also there is address registers along with comparator. Address comparison is done in comparator during address phase.
	-> There are two control register(CR1 and CR2) and two status regitser (SR1&SR2).
	-> There is Clock control register(CCR), which controls the serial clock coming out of the Pin SCL.
	
	
	I2C Peripheral clock and Serial Line Clock
	         
			 ->STM32F407 MCU has three I2C Peripherals, all three I2C peripherals are connected to APB1(Max 42Mhz) System Bus.
			 ->Ref figure "I2C peripheral clock" in notes.
			 ->From APB1 bus clock is given to multiplexer which is handled by "control bits" of Control  register.
			 ->The minimum value of these control bus is "2". 0 and 1 is not allowed in this case - thats the design.
			 ->So the minimum peripheral frequency(fpclk) which can be supplied is 2Mhz and Maximum is 42Mhz.
			 -> By using this fplck, the I2C clock circuitry generate I2C serial block.
             ->This MCU can produce up to 400Khz if its in Fast Mode and 100Khz in standard mode.
			 
     NOTE : 1)fpclk(Peripheral clock frequency) must be at least 2Mhz in order to achieve standard mode i2c frequencies that are upto 100Khz.
            2)fpclk must be at least 4Mhz in order to achieve fast mode i2c frequencies that are above 100Khz and below 400Khz. 
			3)fpclk must be in multiples of 10Mhz to reach max 400khz in FM i2c frequency.
			
			
			
	
	I2C IRQs and Interrupt Mapping
	       
		    ->Referring Table 124. I2C Interrupt requests (Page 858 of RM0090)
			->Refer I2C interrupting Processor in notes.
			->Refer Figure 245. I2C interrupt mapping diagram(Page 859 of RM0090).
			->from 245, it_event is for i2c event and it_error is for i2c error.Unlike SPI, i2c has seperate line interrupting processor for errors.
	        ->SB (Start bit sent from master ) Start Condition -  This bit is applicable only to master.
			->ADDR ( Address sent(master) / address matched(slave)) 
			->refer 124 for all other events and error.
			
			I2C Specific Error.
			->Bus Error : This error happens when interface detects an SDA rising or falling edge while SCL is high, occurring in a non valid position
			              During the byte transfer.
		    ->Arbitration Loss Error : This error happens when the interface loses the arbitration of bus to another master.
			->ACK failure error : happens when no ACK is returned for the byte sent.
			->Overrun Error:  Happens during reception, when new byte is received and data register has not been read yet and new byte is lost.
			                  Whenever this error happens it is sure that at least one byte is lost.
			->Under-run error: This happens in TX, when new byte has to be sent and data register has not been written yet and same byte is sent twice.
			Clock stretching can be used to prevent Overrun and Under-run error.
			->PEC error : Happens when there is CRC mismatch , if CRC feature is enabled.
			->Time out error : Happens when master / slave stretches the clock by holding it low more than the recommended amount of time.
      
        I2C IRQ Numbers
             ->refer vector table.
             ->I2C1_EV (Event interrupt) -- Connected to 31st line of NVIC.			 
             ->I2C1_ER (Error interrupt) -- Connected to 32nd line of NVIC.	
             ->I2C2_EV - 33			 
             ->I2C3_ER - 72			 
             ->I2C3_ER - 73

    I2C PERIPHERAL Registers
            
            *I2C Control register 1 (I2C_CR1)
                    ->PE(0th bit) - Enables(1) the I2C peripheral. It is always recommended to make this bit 1 after all other initialization is done.
                    ->NOSTRETCH(7th bit) - this field is 0 by default, which means "Clock stretching" is enabled by default.
                                            This bit is used to disable clock stretching in slave mode when ADDR or BTF flag is set, until
                                            it is reset by software.
                                                    0: Clock stretching enabled
                                                    1: Clock stretching disabled
                    ->START(8th ) - When master make this bit 1, start condition is generated.
					                If you set this bit to 1 being in SLAVE mode, device will automatically become master generating start condition.
									So slave becomes master.(if device is in slave mode and wants to master then it has to set this bit 1).
				    ->STOP(9th) - Used to generate STOP condition.
                    ->ACK(10th) - Used to enable the hardware ACK feature of I2C peripheral. As ACK plays very important role it is necessary to make this bit 
                                  set to 1 which sends ACK for every byte transfered.
								  If this bit is not set, NACK will be sent for reception of bytes(applicable to both slave&master).
				    ->PEC - for packet error checking.
					->SWRST - used to reset peripheral when error occurs.
			
			*I2C Control register 2 (I2C_CR2)
			        -> Bits 5:0 FREQ[5:0]: Peripheral clock frequency
					     50 MHz (peripheral intrinsic maximum limit).
                                  0b000000: Not allowed
                                  0b000001: Not allowed
                                  0b000010: 2 MHz
                                  ...
                                  ...
                                  ...
                                 0b110010: 50 MHz
                                 Higher than 0b100100: Not allowed
					->ITBUFEN: Buffer interrupt enable
                      ITEVTEN: Event interrupt enable
                      ITERREN: Error interrupt enable
                      Unless we make above bits to 1 ,you won't get I2C event/error/buffer interrupts.					  
								  
	****
	Thare are two address register to set slave address, hence each slave can have two different addresses.
	
	        *I2C Own address register 1 (I2C_OAR1)
			        ->By using this register, you can mention both 7&10 bit addresses.
					->If 7bit addressing is used the it should stored in ADD[7:1]properly, in this case ADD0(bit-0) is don't care and ADDMODE(bit-15) should be made 0 in 7bit 
					  addressing mode. It is made 1 for 10bit addressing.
			
            *I2C Own address register 2 (I2C_OAR2)
                    ->Similar way this is used to set another own address.

            *I2C Data register (I2C_DR)
                    ->Data register is used tx/rx data over any serial protocol. 
                    -> In I2C there is only 8 bit data frame unlike SPI. Hence bit 8 to bi 15 are reserved fro this register.
                    ->When device is in TX/RX mode
					
                      Transmitter mode: Byte transmission starts automatically when a byte is written in the DR register. A continuous transmit stream can be
					  maintained if the next data to be transmitted is put in DR once the transmission is started (TxE=1). That is TxE=1 is indication to put
                      next data byte in DR.
					  
					  Receiver mode: Received byte is copied into DR (RxNE=1). A continuous transmit stream can be maintained if DR is read before the next 
					  data byte is received (RxNE=1). So whenever RxNE interrupt is received its clear that there is a data received which has to be read.
					  
			*I2C Status register 1 (I2C_SR1)
                    ->SB(0th) - (valid only for master) if master successfully generate start condition, then this bit is set 1 by hardware.	
                    ->ADDR(bit 1) - For Master, if ADDR =1, then address phase is completed.
                                    For slave, if ADDR =1, slave address is successfully matched.
                     SB & ADDR are set by hardware, but should be cleared by firmware.
					 
					->BTF(Bit 2): Byte transfer finished - This is very important flag which makes sense only when clock stretching is enabled.
					  During TX of data,if TXE =1 and shift register is also empty(that is both data and shift register are empty) then BTF=1, and
					  i2c clock is stretched to low to prevent under-run.
					  
					  During RX of data,if RXNE =1 and shift register is also full(that is both data and shift register are full) then BTF=1, and
					  i2c clock is stretched to low to prevent overrun.
					 
					  So for master/slave if BTF =1, then its clear that i2c communication is momentarily paused untill BTF is cleared by writing to/ reading from
					  data register.
					  
					->Bit 4 STOPF: Stop detection (slave mode) - if this bit is 1 that means that slave has detected stop condition raised by master. this is set by
					 hardware and should be cleared by software.
					 
					->Bit 6 RxNE: Data register not empty (receivers) - if this flag=1, then it means shift register has received new data byte and stored in data register.
					so a new data is waiting to be read from in the data register. This flag is not set during address phase This flag must be used during the reception, 
					firmware has to poll for this or raise interrupt when this flag is set to read data from DR. RxNE flag will be automatically cleared when DR is read.
					
				    ->Bit 7 TxE: Data register empty (transmitters) - Use of this flag is must during the data transmission. If TxE=1, then it means data register is empty and
					it is right time to put data int DR for transmission. This flag is not set during address phase. a write into DR automatically clears the TxE flag.
					  
					  
			*I2C Clock control register (I2C_CCR)
                    ->CCR[11:0]: Clock control register in Fm/Sm mode (Master mode) - CCR is value is calculated based on given formula.
					
					
					
					
					
	How to do Data transmission in I2C Master mode?
	     ->Lets take a case of TX of 3 bytes for simplicity.
		 
		 1)Master firmware generate START Condition.
		 2)Firmware has to wait until SB=1 , to confirm that START condition is successfully generated.
		 3)Master goes for address phase where it writes addresses along with read/write bit=0.
		 4)Master wait here untill ADDR=1, which confirms address phase is completed. ADDR flag is set only after ACK is received from slave for address sent.
		 5)Master should clear above ADDR flag, until ADDR flag is not cleared I2C will be in wait state by stretching clock to low.
		 6)Once AADR is cleared , I2C comes up from wait state and TxE will be Set.(Here DR and SR are emty). Here 1st byte is loaded into DR  which is then loaded into SR. and DR goes emty again. 
		  Count is decremented.(Initially count =3) , now Count =2
		 7)As Dr goes empty again, TxE=1, here we write the 2nd Byte to DR. Count is decremented. now count =1.
		 8)When shift register finished transmission of byte1 it gets ACK from slave. its start sending byte2 and DR gets empty and TXE=1, and byte 3 is loaded
		 into DR, count is decremented , count =0.
		 9)Since count=0, all bytes have been written hence no TxE interrupt is required. So buffer interrupt is disabled.
		 10) When byte2 is transfered, TxE=1 , but no interrupt is generated.
		 11)SR now get loaded with 3rd Byte and gets ACK from slave.
		 12)Now both SR and DR is empty, so BTF goes high and Clock is stretched.
		 13)When BTF=1, interrupt is generated where we can check count value and its its 0, we generate STOP Condition.
		 
		 (Refer the video----> 44. I2C MasterSlave Communication--1. How I2C Master TX data ).
		 
		 
    How Master Receives the Data from slave ? 		 
	    ->case1: Receiving only 1byte from slve.
		
		 1)Master firmware generate START Condition.
		 2)Firmware has to wait until SB=1 , to confirm that START condition is successfully generated.
		 3)Master goes for address phase where it writes addresses along with read/write bit =1 .
		 4)Master wait here until ADDR=1, which confirms address phase is completed. ADDR flag is set only after ACK is received from slave for address sent.
		   Master should clear above ADDR flag, until ADDR flag is not cleared I2C will be in wait state by stretching clock to low. After clearing ADDR bit, 
		   I2C interface will enter into master receive mode. In receive mode I2C engine receive data over SDA line into DR via SR.
		 5)But before clearing the ADDR bit, you have to disable ACK because after the 1st byte reception master should send NACK to slave but not the ACK.
		   Then configure STOP bit to generate stop condition(It wont generate STOP condition immediately since I2C is in wait state), Now clear the ADDR flag.
         6)once ADDR bit is cleared, I2C comes immediately out of wait state and gets 1byte in shift register. Since ACK is disabled already, NACK is sent to slave
          and data byte will be transfered to DR which triggers RXNE interrupt fallowed by STOP condition. In RXNE interrupt you can read the byte sent.
		  
        ->Case2: Receiving 2 bytes from slave.
        
         1)When ADDR flag =1, Clock is stretched and I2C is in  wait state.
         2)Now we disable ACK(ACK=0) and set the The POS=1. 
                 POS: Acknowledge/PEC Position (for data reception)
                    -POS =0: In this case  ACK(Bit 10) controls the Acknowledge/Not-Acknowledge of current byte received in shift register.
                    -POS =1: In this case  ACK(Bit 10) controls the Acknowledge/Not-Acknowledge of Next byte received in shift register.
		 3)Before clearing the ADDR bit, make ACK=0 POS=1. Now Clear the ADDR flag. 
         4)Once ADDR flag is cleared, now data1 will be received in master SR from slave SR, and ACK is sent to slave even though ACK is made 0, this is because
          we made POS=1.
         5)Content of Master SR will be moved to the DR and RxNE flag goes high indicating DR is not Empty.	 Since ACK is sent to slave for Data1 reception,
          slave assumes that master want next byte so it sends Data2. Since we made ACK=0 and POS=1, NACK will be sent to slave.
         6)Now in masters I2C engine both SR and DR are full, BTF flag is set and clock is stretched to make i2c to wait state. So now all firmware has to do in
          BTF handler code is to read data1 and data2.
         7)What exactly firmware does in the BTF handler is - first generate stop condition the read data register twice.

        ->case3: Receiving (N>2) bytes from slave.
           
            1)Lets assume that there is need to receive 100 bytes from slave, N=100th byte, N-1=99th byte and N-2=98th byte.
			2)From 1st byte to 97th byte(i.e N-3 )  carry out the reception in a normal way , that is wiat for RxNE=1 then read from DR.
			3)Once you reach till N-2 byte, fallow below steps:-
			            3.1)First wait until BTF=1,(that is N-2 is in DR and N-1 is in SR and also both SR=DR=full). So clock is stretched to low.
                        3.2)In BTF handler, first disable ACK then read data register.
                        3.3)Now N-1 is in DR and Nth Byte is in SR. Now again BTF=1.
                        3.4)Now in BTF handler configure stop condition then read the last two bytes.	

    How slave transfer the data ?
           
            1)Master sends the address along with r/w = 1, if address matches slave sends ACK.
            2)Now ADDR=1, since slave address is matched. and when ADDR is cleared slave fall into Tx mode.
            3)Initially both DR and SR are empty so TxE goes high until slave writes any data into DR.
            4)After this for every TxE interrupt slave sends one data byte and master sends ACK.
            5)When master no longer wants to any data from slave it sends out NACK.
            6)When NACK is received it causes the ACK-failure interrupt in slave---> where slave assumes that it is an indication from master to end comm.
              Then master will generate stop condition which makes stop flag to be set in slave.

  **********************************I2C Driver development*****************************************

      -> Dual addressing mode - each I2C device can be addressed using 2 addresses.  
      -> If master wants to talk to all the slave then it can use general call address which is o, if slave enables general call mode then it responds to 0 sent by master.
	  
				
___________________________________________________________________________________________________________________________________________________________________________________________________________
*******************************************USART(Universal Synchronous Asynchronous Receiver Transmitter)*************************************************************************

USART Functional Block Diagram

    Refer : Figure 296. USART block diagram (Page 968 of RM0090)

    -> It can be used for both synchronous and asynchronous modes 
	-> We Can see 4 important pins used in UART, TX, RX, nRTS and nCTS.
	-> If it is used in synchronous mode then Serial clock CK is used.
	->Since USART is full duplex tx and rx can happen simultaneously.
	->For Tx and Rx functionality there are two data registers- TDR (Transmit data register) and RDR (receive data register). Each data register has its 
	  associated shift register.
	->Couple of Control registers used to control tx and rx block.
	->Conventional baud rate generator - generates proper baud rate.
	->USART_BRR register must be configured with correct DIV_Mantissa and DIV_Fraction to produce desired baud rate.
	
	
UART PERIPHERAL Clock.
      ->USART1 and USART6 APB2 Bus(84Mhz Max)
	  ->USART2, USART3, UART4 and UART5 are connected to APB1 bus(42Mhz max).
	  
UART Transmitter
      ->Heart of the transmitter is Transmit Shift register, where parallel data is converted into serial data.
	  ->Transmit shift register obtain data from TDR, TDR is loaded with data by software. Data is not loaded into that Transmit shift register until stop is 
	   transmitted from previous load. As soon as last bit is transmitted the new data is loaded into shift register from TDR.

	Steps to set up UART data transmission
       1)Program the M bit in the USART_CR1 register to define the word length. There are options for 9bit or 8bit.
	   2)Program the number of STOP bits in USART_CR2 register.
	   3)Select the desired baud rate using USART_BRR register. Before baud rate selection you have to see Table 134. Error calculation for programmed baud rates 
	   at fPCLK = 8 MHz or fPCLK = 12 MHz, oversampling by 16(1) (page 980 of RM0090) and you must know your peripheral clock frequency, because peripheral frequency
	   puts a limit on the baud rate which you can generate.
	   4)Set the TE bit in the USART_CR1 to enable the Transmit block.
       5) Now enable the USART by writing the UE bit in USART_CR1 register to 1.
       6)If TXE flag is set the write data bytes to send USART_DR register. Repeat this fro each data to be transmitted.
       7)After writing last data into the USART_DR register, wait until TC=1. This indicates that transmission of last  frame is complete.
        Note: After transmission if software wants to disable USAR then it has do it after TC=1.

UART Receiver
    ->The heart of the Receiver is the Receive shift register, where derial data is converted into parallel data.
    ->After sampling the Rx pin for the stop bit, Received data bits in shift register are transfered to the RDR.	
	 
	Steps to set up UART data reception
	   1)Program the M bit in the USART_CR1 register to define the word length. Both transmitter and receiver must agree on word length.
	   2)Program the number of STOP bits in USART_CR2 register.
	   3)Select the desired baud rate using USART_BRR register. Baud rate must be same for both rx and tx.
	   4)Enable the USART by writing the UE bit in USART_CR1 register to 1.
	   5)Set the RE bit in the USART_CR1 to enable the Receive block.
	   6)Once receiver block is enabled it start searching for start bit. When a character is received wait until the RXNE flag is set, then read the RDR.
	   7)RXNE flag must be cleared by reading data register, before the end of reception of the next character to avoid an overrun error.(Refer usart receiver
	   video for timing diagram)
	   
	   
	   
USART INTERRUPT
Ref : Figure 320. USART interrupt mapping diagram (page 1006 of RM0090)

    ->From figure we can see that, only one line is going to NVIC of the processor. All the different event of USART will trigger an interrupt on this line.
	->IRQ number of this line is 34. 
	-> Table 147. USART interrupt requests - gives various USART interrupts.
	
	
	
Control register 1 (USART_CR1)	
       ->TE(Transmitter enable) and RE(Receiver enable) field are used to enable TX block and RX block respectively. 
	   ->IDLEIE - IDLE interrupt enable
	     RXNEIE - RXNE interrupt enable
		 TCIE - Transmission complete interrupt enable
		 TXEIE - TXE interrupt enable
	   ->PEIE(PE interrupt enable) - During transmission if parity error occurs parity flag is set , in this case if PEIE is enabled and parity interrupt occurs.
	   ->PS(Parity selection) - This bit selects the odd or even parity when the parity generation/detection is enabled (PCE set). So this PS bit is valid only 
	   when PCE bit enabled.
	   ->M: Word length
	   ->UE: USART enable
	   ->OVER8: Oversampling mode - oversampling is used by receiver engine to sample rx line. 
	   
Control register 2 (USART_CR2)
       ->This register is used to control synchronous communication of peripheral. - skipped as of now.

Control register 3 (USART_CR3)
       ->Used to configure CTS RTS and error interrupts. It is also used to set peripheral DMA.
       ->EIE: Error interrupt enable - used to enable error interrupts such as frame error, noise error,overrun error ect.
	   
DATA Register - As USART is full duplex , there are two data registers. TDR provides parallel interface between internal bus and output shift register. RDR 
provides parallel interface between internal bus and input shift register. TDR and RDR are not directly accessible by software, but thery are accessible by 
Data register (USART_DR).


Status register (USART_SR)
         ->PE: Parity error - This bit is set when parity error occurs in receiver mode. This bit also triggers interrupts if PEIE is enabled in CR1.
         ->FE: Framing error - This bit is set by hardware when a de-synchronization, excessive noise or a break character is detected.	 
	     ->NF: Noise detected flag - This bit is set by hardware when noise is detected on a received frame.
		 ->ORE: Overrun error
		 ->IDLE: IDLE line detected
		 ->RXNE: Read data register not empty - This bit is set by hardware when the content of the RDR shift register has been transferred to the 
		         USART_DR register. So Firmware has to wait until this bit is set to read the DR. 
		 ->TC: Transmission complete - firmware has to wait until TC =1 to disable UART after transmission is completed. 
         ->TXE: Transmit data register empty - Set when TDR is empty. It is cleared by a write to the USART_DR register.		 
	
	
Baud rate register (USART_BRR)
         ->Proper value should be set for DIV_Mantissa[11:0] and DIV_Fraction[3:0]. 
         -> The value of USART_BRR is called USARTDIV. 



UART Interrupt handling driver code - Refer notes diagram. 



      ->static void hal_uart_handle_TXE_interrupt(uart_handle_t *huart) =  Refer notes diagram for flow chart.  		 